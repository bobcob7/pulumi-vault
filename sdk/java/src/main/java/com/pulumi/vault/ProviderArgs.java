// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vault.inputs.ProviderAuthLoginArgs;
import com.pulumi.vault.inputs.ProviderClientAuthArgs;
import com.pulumi.vault.inputs.ProviderHeaderArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ProviderArgs extends com.pulumi.resources.ResourceArgs {

    public static final ProviderArgs Empty = new ProviderArgs();

    /**
     * If true, adds the value of the `address` argument to the Terraform process environment.
     * 
     */
    @Import(name="addAddressToEnv")
    private @Nullable Output<String> addAddressToEnv;

    /**
     * @return If true, adds the value of the `address` argument to the Terraform process environment.
     * 
     */
    public Optional<Output<String>> addAddressToEnv() {
        return Optional.ofNullable(this.addAddressToEnv);
    }

    /**
     * URL of the root of the target Vault server.
     * 
     */
    @Import(name="address", required=true)
    private Output<String> address;

    /**
     * @return URL of the root of the target Vault server.
     * 
     */
    public Output<String> address() {
        return this.address;
    }

    /**
     * Login to vault with an existing auth method using auth/&lt;mount&gt;/login
     * 
     */
    @Import(name="authLogins", json=true)
    private @Nullable Output<List<ProviderAuthLoginArgs>> authLogins;

    /**
     * @return Login to vault with an existing auth method using auth/&lt;mount&gt;/login
     * 
     */
    public Optional<Output<List<ProviderAuthLoginArgs>>> authLogins() {
        return Optional.ofNullable(this.authLogins);
    }

    /**
     * Path to directory containing CA certificate files to validate the server&#39;s certificate.
     * 
     */
    @Import(name="caCertDir")
    private @Nullable Output<String> caCertDir;

    /**
     * @return Path to directory containing CA certificate files to validate the server&#39;s certificate.
     * 
     */
    public Optional<Output<String>> caCertDir() {
        return Optional.ofNullable(this.caCertDir);
    }

    /**
     * Path to a CA certificate file to validate the server&#39;s certificate.
     * 
     */
    @Import(name="caCertFile")
    private @Nullable Output<String> caCertFile;

    /**
     * @return Path to a CA certificate file to validate the server&#39;s certificate.
     * 
     */
    public Optional<Output<String>> caCertFile() {
        return Optional.ofNullable(this.caCertFile);
    }

    /**
     * Client authentication credentials.
     * 
     */
    @Import(name="clientAuths", json=true)
    private @Nullable Output<List<ProviderClientAuthArgs>> clientAuths;

    /**
     * @return Client authentication credentials.
     * 
     */
    public Optional<Output<List<ProviderClientAuthArgs>>> clientAuths() {
        return Optional.ofNullable(this.clientAuths);
    }

    /**
     * The headers to send with each Vault request.
     * 
     */
    @Import(name="headers", json=true)
    private @Nullable Output<List<ProviderHeaderArgs>> headers;

    /**
     * @return The headers to send with each Vault request.
     * 
     */
    public Optional<Output<List<ProviderHeaderArgs>>> headers() {
        return Optional.ofNullable(this.headers);
    }

    /**
     * Maximum TTL for secret leases requested by this provider.
     * 
     */
    @Import(name="maxLeaseTtlSeconds", json=true)
    private @Nullable Output<Integer> maxLeaseTtlSeconds;

    /**
     * @return Maximum TTL for secret leases requested by this provider.
     * 
     */
    public Optional<Output<Integer>> maxLeaseTtlSeconds() {
        return Optional.ofNullable(this.maxLeaseTtlSeconds);
    }

    /**
     * Maximum number of retries when a 5xx error code is encountered.
     * 
     */
    @Import(name="maxRetries", json=true)
    private @Nullable Output<Integer> maxRetries;

    /**
     * @return Maximum number of retries when a 5xx error code is encountered.
     * 
     */
    public Optional<Output<Integer>> maxRetries() {
        return Optional.ofNullable(this.maxRetries);
    }

    /**
     * Maximum number of retries for Client Controlled Consistency related operations
     * 
     */
    @Import(name="maxRetriesCcc", json=true)
    private @Nullable Output<Integer> maxRetriesCcc;

    /**
     * @return Maximum number of retries for Client Controlled Consistency related operations
     * 
     */
    public Optional<Output<Integer>> maxRetriesCcc() {
        return Optional.ofNullable(this.maxRetriesCcc);
    }

    /**
     * The namespace to use. Available only for Vault Enterprise.
     * 
     */
    @Import(name="namespace")
    private @Nullable Output<String> namespace;

    /**
     * @return The namespace to use. Available only for Vault Enterprise.
     * 
     */
    public Optional<Output<String>> namespace() {
        return Optional.ofNullable(this.namespace);
    }

    /**
     * Set this to true to prevent the creation of ephemeral child token used by this provider.
     * 
     */
    @Import(name="skipChildToken", json=true)
    private @Nullable Output<Boolean> skipChildToken;

    /**
     * @return Set this to true to prevent the creation of ephemeral child token used by this provider.
     * 
     */
    public Optional<Output<Boolean>> skipChildToken() {
        return Optional.ofNullable(this.skipChildToken);
    }

    /**
     * Set this to true only if the target Vault server is an insecure development instance.
     * 
     */
    @Import(name="skipTlsVerify", json=true)
    private @Nullable Output<Boolean> skipTlsVerify;

    /**
     * @return Set this to true only if the target Vault server is an insecure development instance.
     * 
     */
    public Optional<Output<Boolean>> skipTlsVerify() {
        return Optional.ofNullable(this.skipTlsVerify);
    }

    /**
     * Name to use as the SNI host when connecting via TLS.
     * 
     */
    @Import(name="tlsServerName")
    private @Nullable Output<String> tlsServerName;

    /**
     * @return Name to use as the SNI host when connecting via TLS.
     * 
     */
    public Optional<Output<String>> tlsServerName() {
        return Optional.ofNullable(this.tlsServerName);
    }

    /**
     * Token to use to authenticate to Vault.
     * 
     */
    @Import(name="token", required=true)
    private Output<String> token;

    /**
     * @return Token to use to authenticate to Vault.
     * 
     */
    public Output<String> token() {
        return this.token;
    }

    /**
     * Token name to use for creating the Vault child token.
     * 
     */
    @Import(name="tokenName")
    private @Nullable Output<String> tokenName;

    /**
     * @return Token name to use for creating the Vault child token.
     * 
     */
    public Optional<Output<String>> tokenName() {
        return Optional.ofNullable(this.tokenName);
    }

    private ProviderArgs() {}

    private ProviderArgs(ProviderArgs $) {
        this.addAddressToEnv = $.addAddressToEnv;
        this.address = $.address;
        this.authLogins = $.authLogins;
        this.caCertDir = $.caCertDir;
        this.caCertFile = $.caCertFile;
        this.clientAuths = $.clientAuths;
        this.headers = $.headers;
        this.maxLeaseTtlSeconds = $.maxLeaseTtlSeconds;
        this.maxRetries = $.maxRetries;
        this.maxRetriesCcc = $.maxRetriesCcc;
        this.namespace = $.namespace;
        this.skipChildToken = $.skipChildToken;
        this.skipTlsVerify = $.skipTlsVerify;
        this.tlsServerName = $.tlsServerName;
        this.token = $.token;
        this.tokenName = $.tokenName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ProviderArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ProviderArgs $;

        public Builder() {
            $ = new ProviderArgs();
        }

        public Builder(ProviderArgs defaults) {
            $ = new ProviderArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param addAddressToEnv If true, adds the value of the `address` argument to the Terraform process environment.
         * 
         * @return builder
         * 
         */
        public Builder addAddressToEnv(@Nullable Output<String> addAddressToEnv) {
            $.addAddressToEnv = addAddressToEnv;
            return this;
        }

        /**
         * @param addAddressToEnv If true, adds the value of the `address` argument to the Terraform process environment.
         * 
         * @return builder
         * 
         */
        public Builder addAddressToEnv(String addAddressToEnv) {
            return addAddressToEnv(Output.of(addAddressToEnv));
        }

        /**
         * @param address URL of the root of the target Vault server.
         * 
         * @return builder
         * 
         */
        public Builder address(Output<String> address) {
            $.address = address;
            return this;
        }

        /**
         * @param address URL of the root of the target Vault server.
         * 
         * @return builder
         * 
         */
        public Builder address(String address) {
            return address(Output.of(address));
        }

        /**
         * @param authLogins Login to vault with an existing auth method using auth/&lt;mount&gt;/login
         * 
         * @return builder
         * 
         */
        public Builder authLogins(@Nullable Output<List<ProviderAuthLoginArgs>> authLogins) {
            $.authLogins = authLogins;
            return this;
        }

        /**
         * @param authLogins Login to vault with an existing auth method using auth/&lt;mount&gt;/login
         * 
         * @return builder
         * 
         */
        public Builder authLogins(List<ProviderAuthLoginArgs> authLogins) {
            return authLogins(Output.of(authLogins));
        }

        /**
         * @param authLogins Login to vault with an existing auth method using auth/&lt;mount&gt;/login
         * 
         * @return builder
         * 
         */
        public Builder authLogins(ProviderAuthLoginArgs... authLogins) {
            return authLogins(List.of(authLogins));
        }

        /**
         * @param caCertDir Path to directory containing CA certificate files to validate the server&#39;s certificate.
         * 
         * @return builder
         * 
         */
        public Builder caCertDir(@Nullable Output<String> caCertDir) {
            $.caCertDir = caCertDir;
            return this;
        }

        /**
         * @param caCertDir Path to directory containing CA certificate files to validate the server&#39;s certificate.
         * 
         * @return builder
         * 
         */
        public Builder caCertDir(String caCertDir) {
            return caCertDir(Output.of(caCertDir));
        }

        /**
         * @param caCertFile Path to a CA certificate file to validate the server&#39;s certificate.
         * 
         * @return builder
         * 
         */
        public Builder caCertFile(@Nullable Output<String> caCertFile) {
            $.caCertFile = caCertFile;
            return this;
        }

        /**
         * @param caCertFile Path to a CA certificate file to validate the server&#39;s certificate.
         * 
         * @return builder
         * 
         */
        public Builder caCertFile(String caCertFile) {
            return caCertFile(Output.of(caCertFile));
        }

        /**
         * @param clientAuths Client authentication credentials.
         * 
         * @return builder
         * 
         */
        public Builder clientAuths(@Nullable Output<List<ProviderClientAuthArgs>> clientAuths) {
            $.clientAuths = clientAuths;
            return this;
        }

        /**
         * @param clientAuths Client authentication credentials.
         * 
         * @return builder
         * 
         */
        public Builder clientAuths(List<ProviderClientAuthArgs> clientAuths) {
            return clientAuths(Output.of(clientAuths));
        }

        /**
         * @param clientAuths Client authentication credentials.
         * 
         * @return builder
         * 
         */
        public Builder clientAuths(ProviderClientAuthArgs... clientAuths) {
            return clientAuths(List.of(clientAuths));
        }

        /**
         * @param headers The headers to send with each Vault request.
         * 
         * @return builder
         * 
         */
        public Builder headers(@Nullable Output<List<ProviderHeaderArgs>> headers) {
            $.headers = headers;
            return this;
        }

        /**
         * @param headers The headers to send with each Vault request.
         * 
         * @return builder
         * 
         */
        public Builder headers(List<ProviderHeaderArgs> headers) {
            return headers(Output.of(headers));
        }

        /**
         * @param headers The headers to send with each Vault request.
         * 
         * @return builder
         * 
         */
        public Builder headers(ProviderHeaderArgs... headers) {
            return headers(List.of(headers));
        }

        /**
         * @param maxLeaseTtlSeconds Maximum TTL for secret leases requested by this provider.
         * 
         * @return builder
         * 
         */
        public Builder maxLeaseTtlSeconds(@Nullable Output<Integer> maxLeaseTtlSeconds) {
            $.maxLeaseTtlSeconds = maxLeaseTtlSeconds;
            return this;
        }

        /**
         * @param maxLeaseTtlSeconds Maximum TTL for secret leases requested by this provider.
         * 
         * @return builder
         * 
         */
        public Builder maxLeaseTtlSeconds(Integer maxLeaseTtlSeconds) {
            return maxLeaseTtlSeconds(Output.of(maxLeaseTtlSeconds));
        }

        /**
         * @param maxRetries Maximum number of retries when a 5xx error code is encountered.
         * 
         * @return builder
         * 
         */
        public Builder maxRetries(@Nullable Output<Integer> maxRetries) {
            $.maxRetries = maxRetries;
            return this;
        }

        /**
         * @param maxRetries Maximum number of retries when a 5xx error code is encountered.
         * 
         * @return builder
         * 
         */
        public Builder maxRetries(Integer maxRetries) {
            return maxRetries(Output.of(maxRetries));
        }

        /**
         * @param maxRetriesCcc Maximum number of retries for Client Controlled Consistency related operations
         * 
         * @return builder
         * 
         */
        public Builder maxRetriesCcc(@Nullable Output<Integer> maxRetriesCcc) {
            $.maxRetriesCcc = maxRetriesCcc;
            return this;
        }

        /**
         * @param maxRetriesCcc Maximum number of retries for Client Controlled Consistency related operations
         * 
         * @return builder
         * 
         */
        public Builder maxRetriesCcc(Integer maxRetriesCcc) {
            return maxRetriesCcc(Output.of(maxRetriesCcc));
        }

        /**
         * @param namespace The namespace to use. Available only for Vault Enterprise.
         * 
         * @return builder
         * 
         */
        public Builder namespace(@Nullable Output<String> namespace) {
            $.namespace = namespace;
            return this;
        }

        /**
         * @param namespace The namespace to use. Available only for Vault Enterprise.
         * 
         * @return builder
         * 
         */
        public Builder namespace(String namespace) {
            return namespace(Output.of(namespace));
        }

        /**
         * @param skipChildToken Set this to true to prevent the creation of ephemeral child token used by this provider.
         * 
         * @return builder
         * 
         */
        public Builder skipChildToken(@Nullable Output<Boolean> skipChildToken) {
            $.skipChildToken = skipChildToken;
            return this;
        }

        /**
         * @param skipChildToken Set this to true to prevent the creation of ephemeral child token used by this provider.
         * 
         * @return builder
         * 
         */
        public Builder skipChildToken(Boolean skipChildToken) {
            return skipChildToken(Output.of(skipChildToken));
        }

        /**
         * @param skipTlsVerify Set this to true only if the target Vault server is an insecure development instance.
         * 
         * @return builder
         * 
         */
        public Builder skipTlsVerify(@Nullable Output<Boolean> skipTlsVerify) {
            $.skipTlsVerify = skipTlsVerify;
            return this;
        }

        /**
         * @param skipTlsVerify Set this to true only if the target Vault server is an insecure development instance.
         * 
         * @return builder
         * 
         */
        public Builder skipTlsVerify(Boolean skipTlsVerify) {
            return skipTlsVerify(Output.of(skipTlsVerify));
        }

        /**
         * @param tlsServerName Name to use as the SNI host when connecting via TLS.
         * 
         * @return builder
         * 
         */
        public Builder tlsServerName(@Nullable Output<String> tlsServerName) {
            $.tlsServerName = tlsServerName;
            return this;
        }

        /**
         * @param tlsServerName Name to use as the SNI host when connecting via TLS.
         * 
         * @return builder
         * 
         */
        public Builder tlsServerName(String tlsServerName) {
            return tlsServerName(Output.of(tlsServerName));
        }

        /**
         * @param token Token to use to authenticate to Vault.
         * 
         * @return builder
         * 
         */
        public Builder token(Output<String> token) {
            $.token = token;
            return this;
        }

        /**
         * @param token Token to use to authenticate to Vault.
         * 
         * @return builder
         * 
         */
        public Builder token(String token) {
            return token(Output.of(token));
        }

        /**
         * @param tokenName Token name to use for creating the Vault child token.
         * 
         * @return builder
         * 
         */
        public Builder tokenName(@Nullable Output<String> tokenName) {
            $.tokenName = tokenName;
            return this;
        }

        /**
         * @param tokenName Token name to use for creating the Vault child token.
         * 
         * @return builder
         * 
         */
        public Builder tokenName(String tokenName) {
            return tokenName(Output.of(tokenName));
        }

        public ProviderArgs build() {
            $.address = Objects.requireNonNull($.address, "expected parameter 'address' to be non-null");
            $.maxLeaseTtlSeconds = Codegen.integerProp("maxLeaseTtlSeconds").output().arg($.maxLeaseTtlSeconds).env("TERRAFORM_VAULT_MAX_TTL").def(1200).getNullable();
            $.maxRetries = Codegen.integerProp("maxRetries").output().arg($.maxRetries).env("VAULT_MAX_RETRIES").def(2).getNullable();
            $.skipTlsVerify = Codegen.booleanProp("skipTlsVerify").output().arg($.skipTlsVerify).env("VAULT_SKIP_VERIFY").getNullable();
            $.token = Objects.requireNonNull($.token, "expected parameter 'token' to be non-null");
            return $;
        }
    }

}
