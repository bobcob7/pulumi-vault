// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.kubernetes.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetAuthBackendRoleResult {
    /**
     * @return Method used for generating identity aliases. (vault-1.9+)
     * 
     */
    private final String aliasNameSource;
    /**
     * @return Audience claim to verify in the JWT.
     * 
     */
    private final @Nullable String audience;
    private final @Nullable String backend;
    /**
     * @return List of service account names able to access this role. If set to &#34;*&#34; all names are allowed, both this and bound_service_account_namespaces can not be &#34;*&#34;.
     * 
     */
    private final List<String> boundServiceAccountNames;
    /**
     * @return List of namespaces allowed to access this role. If set to &#34;*&#34; all namespaces are allowed, both this and bound_service_account_names can not be set to &#34;*&#34;.
     * 
     */
    private final List<String> boundServiceAccountNamespaces;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private final String id;
    private final String roleName;
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    private final @Nullable List<String> tokenBoundCidrs;
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    private final @Nullable Integer tokenExplicitMaxTtl;
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private final @Nullable Integer tokenMaxTtl;
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    private final @Nullable Boolean tokenNoDefaultPolicy;
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    private final @Nullable Integer tokenNumUses;
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    private final @Nullable Integer tokenPeriod;
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    private final @Nullable List<String> tokenPolicies;
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private final @Nullable Integer tokenTtl;
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    private final @Nullable String tokenType;

    @CustomType.Constructor
    private GetAuthBackendRoleResult(
        @CustomType.Parameter("aliasNameSource") String aliasNameSource,
        @CustomType.Parameter("audience") @Nullable String audience,
        @CustomType.Parameter("backend") @Nullable String backend,
        @CustomType.Parameter("boundServiceAccountNames") List<String> boundServiceAccountNames,
        @CustomType.Parameter("boundServiceAccountNamespaces") List<String> boundServiceAccountNamespaces,
        @CustomType.Parameter("id") String id,
        @CustomType.Parameter("roleName") String roleName,
        @CustomType.Parameter("tokenBoundCidrs") @Nullable List<String> tokenBoundCidrs,
        @CustomType.Parameter("tokenExplicitMaxTtl") @Nullable Integer tokenExplicitMaxTtl,
        @CustomType.Parameter("tokenMaxTtl") @Nullable Integer tokenMaxTtl,
        @CustomType.Parameter("tokenNoDefaultPolicy") @Nullable Boolean tokenNoDefaultPolicy,
        @CustomType.Parameter("tokenNumUses") @Nullable Integer tokenNumUses,
        @CustomType.Parameter("tokenPeriod") @Nullable Integer tokenPeriod,
        @CustomType.Parameter("tokenPolicies") @Nullable List<String> tokenPolicies,
        @CustomType.Parameter("tokenTtl") @Nullable Integer tokenTtl,
        @CustomType.Parameter("tokenType") @Nullable String tokenType) {
        this.aliasNameSource = aliasNameSource;
        this.audience = audience;
        this.backend = backend;
        this.boundServiceAccountNames = boundServiceAccountNames;
        this.boundServiceAccountNamespaces = boundServiceAccountNamespaces;
        this.id = id;
        this.roleName = roleName;
        this.tokenBoundCidrs = tokenBoundCidrs;
        this.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
        this.tokenMaxTtl = tokenMaxTtl;
        this.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
        this.tokenNumUses = tokenNumUses;
        this.tokenPeriod = tokenPeriod;
        this.tokenPolicies = tokenPolicies;
        this.tokenTtl = tokenTtl;
        this.tokenType = tokenType;
    }

    /**
     * @return Method used for generating identity aliases. (vault-1.9+)
     * 
     */
    public String aliasNameSource() {
        return this.aliasNameSource;
    }
    /**
     * @return Audience claim to verify in the JWT.
     * 
     */
    public Optional<String> audience() {
        return Optional.ofNullable(this.audience);
    }
    public Optional<String> backend() {
        return Optional.ofNullable(this.backend);
    }
    /**
     * @return List of service account names able to access this role. If set to &#34;*&#34; all names are allowed, both this and bound_service_account_namespaces can not be &#34;*&#34;.
     * 
     */
    public List<String> boundServiceAccountNames() {
        return this.boundServiceAccountNames;
    }
    /**
     * @return List of namespaces allowed to access this role. If set to &#34;*&#34; all namespaces are allowed, both this and bound_service_account_names can not be set to &#34;*&#34;.
     * 
     */
    public List<String> boundServiceAccountNamespaces() {
        return this.boundServiceAccountNamespaces;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    public String roleName() {
        return this.roleName;
    }
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    public List<String> tokenBoundCidrs() {
        return this.tokenBoundCidrs == null ? List.of() : this.tokenBoundCidrs;
    }
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    public Optional<Integer> tokenExplicitMaxTtl() {
        return Optional.ofNullable(this.tokenExplicitMaxTtl);
    }
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenMaxTtl() {
        return Optional.ofNullable(this.tokenMaxTtl);
    }
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    public Optional<Boolean> tokenNoDefaultPolicy() {
        return Optional.ofNullable(this.tokenNoDefaultPolicy);
    }
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    public Optional<Integer> tokenNumUses() {
        return Optional.ofNullable(this.tokenNumUses);
    }
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    public Optional<Integer> tokenPeriod() {
        return Optional.ofNullable(this.tokenPeriod);
    }
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    public List<String> tokenPolicies() {
        return this.tokenPolicies == null ? List.of() : this.tokenPolicies;
    }
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenTtl() {
        return Optional.ofNullable(this.tokenTtl);
    }
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    public Optional<String> tokenType() {
        return Optional.ofNullable(this.tokenType);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetAuthBackendRoleResult defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private String aliasNameSource;
        private @Nullable String audience;
        private @Nullable String backend;
        private List<String> boundServiceAccountNames;
        private List<String> boundServiceAccountNamespaces;
        private String id;
        private String roleName;
        private @Nullable List<String> tokenBoundCidrs;
        private @Nullable Integer tokenExplicitMaxTtl;
        private @Nullable Integer tokenMaxTtl;
        private @Nullable Boolean tokenNoDefaultPolicy;
        private @Nullable Integer tokenNumUses;
        private @Nullable Integer tokenPeriod;
        private @Nullable List<String> tokenPolicies;
        private @Nullable Integer tokenTtl;
        private @Nullable String tokenType;

        public Builder() {
    	      // Empty
        }

        public Builder(GetAuthBackendRoleResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.aliasNameSource = defaults.aliasNameSource;
    	      this.audience = defaults.audience;
    	      this.backend = defaults.backend;
    	      this.boundServiceAccountNames = defaults.boundServiceAccountNames;
    	      this.boundServiceAccountNamespaces = defaults.boundServiceAccountNamespaces;
    	      this.id = defaults.id;
    	      this.roleName = defaults.roleName;
    	      this.tokenBoundCidrs = defaults.tokenBoundCidrs;
    	      this.tokenExplicitMaxTtl = defaults.tokenExplicitMaxTtl;
    	      this.tokenMaxTtl = defaults.tokenMaxTtl;
    	      this.tokenNoDefaultPolicy = defaults.tokenNoDefaultPolicy;
    	      this.tokenNumUses = defaults.tokenNumUses;
    	      this.tokenPeriod = defaults.tokenPeriod;
    	      this.tokenPolicies = defaults.tokenPolicies;
    	      this.tokenTtl = defaults.tokenTtl;
    	      this.tokenType = defaults.tokenType;
        }

        public Builder aliasNameSource(String aliasNameSource) {
            this.aliasNameSource = Objects.requireNonNull(aliasNameSource);
            return this;
        }
        public Builder audience(@Nullable String audience) {
            this.audience = audience;
            return this;
        }
        public Builder backend(@Nullable String backend) {
            this.backend = backend;
            return this;
        }
        public Builder boundServiceAccountNames(List<String> boundServiceAccountNames) {
            this.boundServiceAccountNames = Objects.requireNonNull(boundServiceAccountNames);
            return this;
        }
        public Builder boundServiceAccountNames(String... boundServiceAccountNames) {
            return boundServiceAccountNames(List.of(boundServiceAccountNames));
        }
        public Builder boundServiceAccountNamespaces(List<String> boundServiceAccountNamespaces) {
            this.boundServiceAccountNamespaces = Objects.requireNonNull(boundServiceAccountNamespaces);
            return this;
        }
        public Builder boundServiceAccountNamespaces(String... boundServiceAccountNamespaces) {
            return boundServiceAccountNamespaces(List.of(boundServiceAccountNamespaces));
        }
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        public Builder roleName(String roleName) {
            this.roleName = Objects.requireNonNull(roleName);
            return this;
        }
        public Builder tokenBoundCidrs(@Nullable List<String> tokenBoundCidrs) {
            this.tokenBoundCidrs = tokenBoundCidrs;
            return this;
        }
        public Builder tokenBoundCidrs(String... tokenBoundCidrs) {
            return tokenBoundCidrs(List.of(tokenBoundCidrs));
        }
        public Builder tokenExplicitMaxTtl(@Nullable Integer tokenExplicitMaxTtl) {
            this.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            return this;
        }
        public Builder tokenMaxTtl(@Nullable Integer tokenMaxTtl) {
            this.tokenMaxTtl = tokenMaxTtl;
            return this;
        }
        public Builder tokenNoDefaultPolicy(@Nullable Boolean tokenNoDefaultPolicy) {
            this.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            return this;
        }
        public Builder tokenNumUses(@Nullable Integer tokenNumUses) {
            this.tokenNumUses = tokenNumUses;
            return this;
        }
        public Builder tokenPeriod(@Nullable Integer tokenPeriod) {
            this.tokenPeriod = tokenPeriod;
            return this;
        }
        public Builder tokenPolicies(@Nullable List<String> tokenPolicies) {
            this.tokenPolicies = tokenPolicies;
            return this;
        }
        public Builder tokenPolicies(String... tokenPolicies) {
            return tokenPolicies(List.of(tokenPolicies));
        }
        public Builder tokenTtl(@Nullable Integer tokenTtl) {
            this.tokenTtl = tokenTtl;
            return this;
        }
        public Builder tokenType(@Nullable String tokenType) {
            this.tokenType = tokenType;
            return this;
        }        public GetAuthBackendRoleResult build() {
            return new GetAuthBackendRoleResult(aliasNameSource, audience, backend, boundServiceAccountNames, boundServiceAccountNamespaces, id, roleName, tokenBoundCidrs, tokenExplicitMaxTtl, tokenMaxTtl, tokenNoDefaultPolicy, tokenNumUses, tokenPeriod, tokenPolicies, tokenTtl, tokenType);
        }
    }
}
