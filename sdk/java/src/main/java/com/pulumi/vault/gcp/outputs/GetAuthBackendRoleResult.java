// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vault.gcp.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetAuthBackendRoleResult {
    private final @Nullable String backend;
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    private final List<String> boundInstanceGroups;
    /**
     * @return GCP labels bound to the role. Returned when `type` is `gce`.
     * 
     */
    private final List<String> boundLabels;
    /**
     * @return GCP projects bound to the role.
     * 
     */
    private final List<String> boundProjects;
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    private final List<String> boundRegions;
    /**
     * @return GCP service accounts bound to the role. Returned when `type` is `iam`.
     * 
     */
    private final List<String> boundServiceAccounts;
    /**
     * @return GCP zones bound to the role. Returned when `type` is `gce`.
     * 
     */
    private final List<String> boundZones;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private final String id;
    /**
     * @return The RoleID of the GCP role.
     * 
     */
    private final String roleId;
    private final String roleName;
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    private final @Nullable List<String> tokenBoundCidrs;
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    private final @Nullable Integer tokenExplicitMaxTtl;
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private final @Nullable Integer tokenMaxTtl;
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    private final @Nullable Boolean tokenNoDefaultPolicy;
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    private final @Nullable Integer tokenNumUses;
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    private final @Nullable Integer tokenPeriod;
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    private final @Nullable List<String> tokenPolicies;
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    private final @Nullable Integer tokenTtl;
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    private final @Nullable String tokenType;
    /**
     * @return Type of GCP role. Expected values are `iam` or `gce`.
     * 
     */
    private final String type;

    @CustomType.Constructor
    private GetAuthBackendRoleResult(
        @CustomType.Parameter("backend") @Nullable String backend,
        @CustomType.Parameter("boundInstanceGroups") List<String> boundInstanceGroups,
        @CustomType.Parameter("boundLabels") List<String> boundLabels,
        @CustomType.Parameter("boundProjects") List<String> boundProjects,
        @CustomType.Parameter("boundRegions") List<String> boundRegions,
        @CustomType.Parameter("boundServiceAccounts") List<String> boundServiceAccounts,
        @CustomType.Parameter("boundZones") List<String> boundZones,
        @CustomType.Parameter("id") String id,
        @CustomType.Parameter("roleId") String roleId,
        @CustomType.Parameter("roleName") String roleName,
        @CustomType.Parameter("tokenBoundCidrs") @Nullable List<String> tokenBoundCidrs,
        @CustomType.Parameter("tokenExplicitMaxTtl") @Nullable Integer tokenExplicitMaxTtl,
        @CustomType.Parameter("tokenMaxTtl") @Nullable Integer tokenMaxTtl,
        @CustomType.Parameter("tokenNoDefaultPolicy") @Nullable Boolean tokenNoDefaultPolicy,
        @CustomType.Parameter("tokenNumUses") @Nullable Integer tokenNumUses,
        @CustomType.Parameter("tokenPeriod") @Nullable Integer tokenPeriod,
        @CustomType.Parameter("tokenPolicies") @Nullable List<String> tokenPolicies,
        @CustomType.Parameter("tokenTtl") @Nullable Integer tokenTtl,
        @CustomType.Parameter("tokenType") @Nullable String tokenType,
        @CustomType.Parameter("type") String type) {
        this.backend = backend;
        this.boundInstanceGroups = boundInstanceGroups;
        this.boundLabels = boundLabels;
        this.boundProjects = boundProjects;
        this.boundRegions = boundRegions;
        this.boundServiceAccounts = boundServiceAccounts;
        this.boundZones = boundZones;
        this.id = id;
        this.roleId = roleId;
        this.roleName = roleName;
        this.tokenBoundCidrs = tokenBoundCidrs;
        this.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
        this.tokenMaxTtl = tokenMaxTtl;
        this.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
        this.tokenNumUses = tokenNumUses;
        this.tokenPeriod = tokenPeriod;
        this.tokenPolicies = tokenPolicies;
        this.tokenTtl = tokenTtl;
        this.tokenType = tokenType;
        this.type = type;
    }

    public Optional<String> backend() {
        return Optional.ofNullable(this.backend);
    }
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundInstanceGroups() {
        return this.boundInstanceGroups;
    }
    /**
     * @return GCP labels bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundLabels() {
        return this.boundLabels;
    }
    /**
     * @return GCP projects bound to the role.
     * 
     */
    public List<String> boundProjects() {
        return this.boundProjects;
    }
    /**
     * @return GCP regions bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundRegions() {
        return this.boundRegions;
    }
    /**
     * @return GCP service accounts bound to the role. Returned when `type` is `iam`.
     * 
     */
    public List<String> boundServiceAccounts() {
        return this.boundServiceAccounts;
    }
    /**
     * @return GCP zones bound to the role. Returned when `type` is `gce`.
     * 
     */
    public List<String> boundZones() {
        return this.boundZones;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return The RoleID of the GCP role.
     * 
     */
    public String roleId() {
        return this.roleId;
    }
    public String roleName() {
        return this.roleName;
    }
    /**
     * @return List of CIDR blocks; if set, specifies blocks of IP
     * addresses which can authenticate successfully, and ties the resulting token to these blocks
     * as well.
     * 
     */
    public List<String> tokenBoundCidrs() {
        return this.tokenBoundCidrs == null ? List.of() : this.tokenBoundCidrs;
    }
    /**
     * @return If set, will encode an
     * [explicit max TTL](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls)
     * onto the token in number of seconds. This is a hard cap even if `token_ttl` and
     * `token_max_ttl` would otherwise allow a renewal.
     * 
     */
    public Optional<Integer> tokenExplicitMaxTtl() {
        return Optional.ofNullable(this.tokenExplicitMaxTtl);
    }
    /**
     * @return The maximum lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenMaxTtl() {
        return Optional.ofNullable(this.tokenMaxTtl);
    }
    /**
     * @return If set, the default policy will not be set on
     * generated tokens; otherwise it will be added to the policies set in token_policies.
     * 
     */
    public Optional<Boolean> tokenNoDefaultPolicy() {
        return Optional.ofNullable(this.tokenNoDefaultPolicy);
    }
    /**
     * @return The
     * [period](https://www.vaultproject.io/docs/concepts/tokens.html#token-time-to-live-periodic-tokens-and-explicit-max-ttls),
     * if any, in number of seconds to set on the token.
     * 
     */
    public Optional<Integer> tokenNumUses() {
        return Optional.ofNullable(this.tokenNumUses);
    }
    /**
     * @return (Optional) If set, indicates that the
     * token generated using this role should never expire. The token should be renewed within the
     * duration specified by this value. At each renewal, the token&#39;s TTL will be set to the
     * value of this field. Specified in seconds.
     * 
     */
    public Optional<Integer> tokenPeriod() {
        return Optional.ofNullable(this.tokenPeriod);
    }
    /**
     * @return List of policies to encode onto generated tokens. Depending
     * on the auth method, this list may be supplemented by user/group/other values.
     * 
     */
    public List<String> tokenPolicies() {
        return this.tokenPolicies == null ? List.of() : this.tokenPolicies;
    }
    /**
     * @return The incremental lifetime for generated tokens in number of seconds.
     * Its current value will be referenced at renewal time.
     * 
     */
    public Optional<Integer> tokenTtl() {
        return Optional.ofNullable(this.tokenTtl);
    }
    /**
     * @return The type of token that should be generated. Can be `service`,
     * `batch`, or `default` to use the mount&#39;s tuned default (which unless changed will be
     * `service` tokens). For token store roles, there are two additional possibilities:
     * `default-service` and `default-batch` which specify the type to return unless the client
     * requests a different type at generation time.
     * 
     */
    public Optional<String> tokenType() {
        return Optional.ofNullable(this.tokenType);
    }
    /**
     * @return Type of GCP role. Expected values are `iam` or `gce`.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetAuthBackendRoleResult defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable String backend;
        private List<String> boundInstanceGroups;
        private List<String> boundLabels;
        private List<String> boundProjects;
        private List<String> boundRegions;
        private List<String> boundServiceAccounts;
        private List<String> boundZones;
        private String id;
        private String roleId;
        private String roleName;
        private @Nullable List<String> tokenBoundCidrs;
        private @Nullable Integer tokenExplicitMaxTtl;
        private @Nullable Integer tokenMaxTtl;
        private @Nullable Boolean tokenNoDefaultPolicy;
        private @Nullable Integer tokenNumUses;
        private @Nullable Integer tokenPeriod;
        private @Nullable List<String> tokenPolicies;
        private @Nullable Integer tokenTtl;
        private @Nullable String tokenType;
        private String type;

        public Builder() {
    	      // Empty
        }

        public Builder(GetAuthBackendRoleResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.backend = defaults.backend;
    	      this.boundInstanceGroups = defaults.boundInstanceGroups;
    	      this.boundLabels = defaults.boundLabels;
    	      this.boundProjects = defaults.boundProjects;
    	      this.boundRegions = defaults.boundRegions;
    	      this.boundServiceAccounts = defaults.boundServiceAccounts;
    	      this.boundZones = defaults.boundZones;
    	      this.id = defaults.id;
    	      this.roleId = defaults.roleId;
    	      this.roleName = defaults.roleName;
    	      this.tokenBoundCidrs = defaults.tokenBoundCidrs;
    	      this.tokenExplicitMaxTtl = defaults.tokenExplicitMaxTtl;
    	      this.tokenMaxTtl = defaults.tokenMaxTtl;
    	      this.tokenNoDefaultPolicy = defaults.tokenNoDefaultPolicy;
    	      this.tokenNumUses = defaults.tokenNumUses;
    	      this.tokenPeriod = defaults.tokenPeriod;
    	      this.tokenPolicies = defaults.tokenPolicies;
    	      this.tokenTtl = defaults.tokenTtl;
    	      this.tokenType = defaults.tokenType;
    	      this.type = defaults.type;
        }

        public Builder backend(@Nullable String backend) {
            this.backend = backend;
            return this;
        }
        public Builder boundInstanceGroups(List<String> boundInstanceGroups) {
            this.boundInstanceGroups = Objects.requireNonNull(boundInstanceGroups);
            return this;
        }
        public Builder boundInstanceGroups(String... boundInstanceGroups) {
            return boundInstanceGroups(List.of(boundInstanceGroups));
        }
        public Builder boundLabels(List<String> boundLabels) {
            this.boundLabels = Objects.requireNonNull(boundLabels);
            return this;
        }
        public Builder boundLabels(String... boundLabels) {
            return boundLabels(List.of(boundLabels));
        }
        public Builder boundProjects(List<String> boundProjects) {
            this.boundProjects = Objects.requireNonNull(boundProjects);
            return this;
        }
        public Builder boundProjects(String... boundProjects) {
            return boundProjects(List.of(boundProjects));
        }
        public Builder boundRegions(List<String> boundRegions) {
            this.boundRegions = Objects.requireNonNull(boundRegions);
            return this;
        }
        public Builder boundRegions(String... boundRegions) {
            return boundRegions(List.of(boundRegions));
        }
        public Builder boundServiceAccounts(List<String> boundServiceAccounts) {
            this.boundServiceAccounts = Objects.requireNonNull(boundServiceAccounts);
            return this;
        }
        public Builder boundServiceAccounts(String... boundServiceAccounts) {
            return boundServiceAccounts(List.of(boundServiceAccounts));
        }
        public Builder boundZones(List<String> boundZones) {
            this.boundZones = Objects.requireNonNull(boundZones);
            return this;
        }
        public Builder boundZones(String... boundZones) {
            return boundZones(List.of(boundZones));
        }
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        public Builder roleId(String roleId) {
            this.roleId = Objects.requireNonNull(roleId);
            return this;
        }
        public Builder roleName(String roleName) {
            this.roleName = Objects.requireNonNull(roleName);
            return this;
        }
        public Builder tokenBoundCidrs(@Nullable List<String> tokenBoundCidrs) {
            this.tokenBoundCidrs = tokenBoundCidrs;
            return this;
        }
        public Builder tokenBoundCidrs(String... tokenBoundCidrs) {
            return tokenBoundCidrs(List.of(tokenBoundCidrs));
        }
        public Builder tokenExplicitMaxTtl(@Nullable Integer tokenExplicitMaxTtl) {
            this.tokenExplicitMaxTtl = tokenExplicitMaxTtl;
            return this;
        }
        public Builder tokenMaxTtl(@Nullable Integer tokenMaxTtl) {
            this.tokenMaxTtl = tokenMaxTtl;
            return this;
        }
        public Builder tokenNoDefaultPolicy(@Nullable Boolean tokenNoDefaultPolicy) {
            this.tokenNoDefaultPolicy = tokenNoDefaultPolicy;
            return this;
        }
        public Builder tokenNumUses(@Nullable Integer tokenNumUses) {
            this.tokenNumUses = tokenNumUses;
            return this;
        }
        public Builder tokenPeriod(@Nullable Integer tokenPeriod) {
            this.tokenPeriod = tokenPeriod;
            return this;
        }
        public Builder tokenPolicies(@Nullable List<String> tokenPolicies) {
            this.tokenPolicies = tokenPolicies;
            return this;
        }
        public Builder tokenPolicies(String... tokenPolicies) {
            return tokenPolicies(List.of(tokenPolicies));
        }
        public Builder tokenTtl(@Nullable Integer tokenTtl) {
            this.tokenTtl = tokenTtl;
            return this;
        }
        public Builder tokenType(@Nullable String tokenType) {
            this.tokenType = tokenType;
            return this;
        }
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }        public GetAuthBackendRoleResult build() {
            return new GetAuthBackendRoleResult(backend, boundInstanceGroups, boundLabels, boundProjects, boundRegions, boundServiceAccounts, boundZones, id, roleId, roleName, tokenBoundCidrs, tokenExplicitMaxTtl, tokenMaxTtl, tokenNoDefaultPolicy, tokenNumUses, tokenPeriod, tokenPolicies, tokenTtl, tokenType, type);
        }
    }
}
