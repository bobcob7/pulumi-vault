// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Immutable;

namespace Pulumi.Vault
{
    public static class Config
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "IDE1006", Justification = 
        "Double underscore prefix used to avoid conflicts with variable names.")]
        private sealed class __Value<T>
        {
            private readonly Func<T> _getter;
            private T _value = default!;
            private bool _set;

            public __Value(Func<T> getter)
            {
                _getter = getter;
            }

            public T Get() => _set ? _value : _getter();

            public void Set(T value)
            {
                _value = value;
                _set = true;
            }
        }

        private static readonly Pulumi.Config __config = new Pulumi.Config("vault");

        private static readonly __Value<string?> _addAddressToEnv = new __Value<string?>(() => __config.Get("addAddressToEnv"));
        /// <summary>
        /// If true, adds the value of the `address` argument to the Terraform process environment.
        /// </summary>
        public static string? AddAddressToEnv
        {
            get => _addAddressToEnv.Get();
            set => _addAddressToEnv.Set(value);
        }

        private static readonly __Value<string?> _address = new __Value<string?>(() => __config.Get("address"));
        /// <summary>
        /// URL of the root of the target Vault server.
        /// </summary>
        public static string? Address
        {
            get => _address.Get();
            set => _address.Set(value);
        }

        private static readonly __Value<ImmutableArray<Pulumi.Vault.Config.Types.AuthLogins>> _authLogins = new __Value<ImmutableArray<Pulumi.Vault.Config.Types.AuthLogins>>(() => __config.GetObject<ImmutableArray<Pulumi.Vault.Config.Types.AuthLogins>>("authLogins"));
        /// <summary>
        /// Login to vault with an existing auth method using auth/&lt;mount&gt;/login
        /// </summary>
        public static ImmutableArray<Pulumi.Vault.Config.Types.AuthLogins> AuthLogins
        {
            get => _authLogins.Get();
            set => _authLogins.Set(value);
        }

        private static readonly __Value<string?> _caCertDir = new __Value<string?>(() => __config.Get("caCertDir"));
        /// <summary>
        /// Path to directory containing CA certificate files to validate the server's certificate.
        /// </summary>
        public static string? CaCertDir
        {
            get => _caCertDir.Get();
            set => _caCertDir.Set(value);
        }

        private static readonly __Value<string?> _caCertFile = new __Value<string?>(() => __config.Get("caCertFile"));
        /// <summary>
        /// Path to a CA certificate file to validate the server's certificate.
        /// </summary>
        public static string? CaCertFile
        {
            get => _caCertFile.Get();
            set => _caCertFile.Set(value);
        }

        private static readonly __Value<ImmutableArray<Pulumi.Vault.Config.Types.ClientAuths>> _clientAuths = new __Value<ImmutableArray<Pulumi.Vault.Config.Types.ClientAuths>>(() => __config.GetObject<ImmutableArray<Pulumi.Vault.Config.Types.ClientAuths>>("clientAuths"));
        /// <summary>
        /// Client authentication credentials.
        /// </summary>
        public static ImmutableArray<Pulumi.Vault.Config.Types.ClientAuths> ClientAuths
        {
            get => _clientAuths.Get();
            set => _clientAuths.Set(value);
        }

        private static readonly __Value<ImmutableArray<Pulumi.Vault.Config.Types.Headers>> _headers = new __Value<ImmutableArray<Pulumi.Vault.Config.Types.Headers>>(() => __config.GetObject<ImmutableArray<Pulumi.Vault.Config.Types.Headers>>("headers"));
        /// <summary>
        /// The headers to send with each Vault request.
        /// </summary>
        public static ImmutableArray<Pulumi.Vault.Config.Types.Headers> Headers
        {
            get => _headers.Get();
            set => _headers.Set(value);
        }

        private static readonly __Value<int?> _maxLeaseTtlSeconds = new __Value<int?>(() => __config.GetInt32("maxLeaseTtlSeconds") ?? Utilities.GetEnvInt32("TERRAFORM_VAULT_MAX_TTL") ?? 1200);
        /// <summary>
        /// Maximum TTL for secret leases requested by this provider.
        /// </summary>
        public static int? MaxLeaseTtlSeconds
        {
            get => _maxLeaseTtlSeconds.Get();
            set => _maxLeaseTtlSeconds.Set(value);
        }

        private static readonly __Value<int?> _maxRetries = new __Value<int?>(() => __config.GetInt32("maxRetries") ?? Utilities.GetEnvInt32("VAULT_MAX_RETRIES") ?? 2);
        /// <summary>
        /// Maximum number of retries when a 5xx error code is encountered.
        /// </summary>
        public static int? MaxRetries
        {
            get => _maxRetries.Get();
            set => _maxRetries.Set(value);
        }

        private static readonly __Value<int?> _maxRetriesCcc = new __Value<int?>(() => __config.GetInt32("maxRetriesCcc"));
        /// <summary>
        /// Maximum number of retries for Client Controlled Consistency related operations
        /// </summary>
        public static int? MaxRetriesCcc
        {
            get => _maxRetriesCcc.Get();
            set => _maxRetriesCcc.Set(value);
        }

        private static readonly __Value<string?> _namespace = new __Value<string?>(() => __config.Get("namespace"));
        /// <summary>
        /// The namespace to use. Available only for Vault Enterprise.
        /// </summary>
        public static string? Namespace
        {
            get => _namespace.Get();
            set => _namespace.Set(value);
        }

        private static readonly __Value<bool?> _skipChildToken = new __Value<bool?>(() => __config.GetBoolean("skipChildToken"));
        /// <summary>
        /// Set this to true to prevent the creation of ephemeral child token used by this provider.
        /// </summary>
        public static bool? SkipChildToken
        {
            get => _skipChildToken.Get();
            set => _skipChildToken.Set(value);
        }

        private static readonly __Value<bool?> _skipTlsVerify = new __Value<bool?>(() => __config.GetBoolean("skipTlsVerify") ?? Utilities.GetEnvBoolean("VAULT_SKIP_VERIFY"));
        /// <summary>
        /// Set this to true only if the target Vault server is an insecure development instance.
        /// </summary>
        public static bool? SkipTlsVerify
        {
            get => _skipTlsVerify.Get();
            set => _skipTlsVerify.Set(value);
        }

        private static readonly __Value<string?> _token = new __Value<string?>(() => __config.Get("token"));
        /// <summary>
        /// Token to use to authenticate to Vault.
        /// </summary>
        public static string? Token
        {
            get => _token.Get();
            set => _token.Set(value);
        }

        private static readonly __Value<string?> _tokenName = new __Value<string?>(() => __config.Get("tokenName"));
        /// <summary>
        /// Token name to use for creating the Vault child token.
        /// </summary>
        public static string? TokenName
        {
            get => _tokenName.Get();
            set => _tokenName.Set(value);
        }

        public static class Types
        {

             public class AuthLogins
             {
                public string? Method { get; set; } = null!;
                public string? Namespace { get; set; } = null!;
                public ImmutableDictionary<string, string>? Parameters { get; set; } = null!;
                public string Path { get; set; }
            }

             public class ClientAuths
             {
                public string CertFile { get; set; }
                public string KeyFile { get; set; }
            }

             public class Headers
             {
                public string Name { get; set; }
                public string Value { get; set; }
            }
        }
    }
}
